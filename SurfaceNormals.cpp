
#include "SurfaceNormals.h"

namespace pmp {

Normal SurfaceNormals::compute_face_normal(const SurfaceMesh& mesh, Face f)
{
    Halfedge h = mesh.halfedge(f);
    Halfedge hend = h;

    auto vpoint = mesh.get_vertex_property<Point>("v:point");

    Point p0 = vpoint[mesh.to_vertex(h)];
    h = mesh.next_halfedge(h);
    Point p1 = vpoint[mesh.to_vertex(h)];
    h = mesh.next_halfedge(h);
    Point p2 = vpoint[mesh.to_vertex(h)];

    if (mesh.next_halfedge(h) == hend) // face is a triangle
    {
        return normalize(cross(p2 -= p1, p0 -= p1));
    }
    else // face is a general polygon
    {
        Normal n(0, 0, 0);

        // this computes the sum of cross products (area-weighted normals)
        // of triangles generated by inserting the centroid c:
        //   sum_i (p_{i} - c) x (p_{i+1} - c)
        // The point c cancels out, leading to
        //   sum_i (p_{i} x p_{i+1}
        // This vector then has to be normalized.
        for (auto h : mesh.halfedges(f))
        {
            n += cross(vpoint[mesh.from_vertex(h)], vpoint[mesh.to_vertex(h)]);
        }

        return normalize(n);
    }
}

Normal SurfaceNormals::compute_vertex_normal(const SurfaceMesh& mesh, Vertex v)
{
    Point nn(0, 0, 0);

    if (!mesh.is_isolated(v))
    {
        auto vpoint = mesh.get_vertex_property<Point>("v:point");
        const Point p0 = vpoint[v];

        Normal n;
        Point p1, p2;
        Scalar cosine, angle, denom;
        bool is_triangle;

        for (auto h : mesh.halfedges(v))
        {
            if (!mesh.is_boundary(h))
            {
                p1 = vpoint[mesh.to_vertex(h)];
                p1 -= p0;
                p2 = vpoint[mesh.from_vertex(mesh.prev_halfedge(h))];
                p2 -= p0;

                // check whether we can robustly compute angle
                denom = sqrt(dot(p1, p1) * dot(p2, p2));
                if (denom > std::numeric_limits<Scalar>::min())
                {
                    cosine = dot(p1, p2) / denom;
                    if (cosine < -1.0)
                        cosine = -1.0;
                    else if (cosine > 1.0)
                        cosine = 1.0;
                    angle = acos(cosine);

                    // compute triangle or polygon normal
                    is_triangle = (mesh.next_halfedge(mesh.next_halfedge(
                        mesh.next_halfedge(h))) == h);
                    n = is_triangle ? normalize(cross(p1, p2))
                        : compute_face_normal(mesh, mesh.face(h));

                    n *= angle;
                    nn += n;
                }
            }
        }

        nn = normalize(nn);
    }

    return nn;
}

Normal SurfaceNormals::compute_corner_normal(const SurfaceMesh& mesh,
                                             Halfedge h, Scalar crease_angle)
{
    // catch the two trivial cases
    if (crease_angle < 0.01)
        return compute_face_normal(mesh, mesh.face(h));
    else if (crease_angle > 179)
        return compute_vertex_normal(mesh, mesh.from_vertex(h));

    // avoid numerical problems
    if (crease_angle < 0.001)
        crease_angle = 0.001;

    const Scalar cos_crease_angle = cos(crease_angle);
    Point nn(0, 0, 0);

    if (!mesh.is_boundary(h))
    {
        auto vpoint = mesh.get_vertex_property<Point>("v:point");

        const Halfedge hend = h;
        const Vertex v0 = mesh.to_vertex(h);
        const Point p0 = vpoint[v0];

        Point n, p1, p2;
        Scalar cosine, angle, denom;
        bool is_triangle;

        // compute normal of h's face
        const Point nf = compute_face_normal(mesh, mesh.face(h));

        // average over all incident faces
        do
        {
            if (!mesh.is_boundary(h))
            {
                p1 = vpoint[mesh.to_vertex(mesh.next_halfedge(h))];
                p1 -= p0;
                p2 = vpoint[mesh.from_vertex(h)];
                p2 -= p0;

                // compute triangle or polygon normal
                is_triangle = (mesh.next_halfedge(mesh.next_halfedge(
                                   mesh.next_halfedge(h))) == h);
                n = is_triangle ? normalize(cross(p1, p2))
                                : compute_face_normal(mesh, mesh.face(h));

                // check whether normal is withing crease_angle bound
                if (dot(n, nf) >= cos_crease_angle)
                {
                    // check whether we can robustly compute angle
                    denom = sqrt(dot(p1, p1) * dot(p2, p2));
                    if (denom > std::numeric_limits<Scalar>::min())
                    {
                        cosine = dot(p1, p2) / denom;
                        if (cosine < -1.0)
                            cosine = -1.0;
                        else if (cosine > 1.0)
                            cosine = 1.0;
                        angle = acos(cosine);

                        n *= angle;
                        nn += n;
                    }
                }
            }

            h = mesh.opposite_halfedge(mesh.next_halfedge(h));
        } while (h != hend);

        nn = normalize(nn);
    }

    return nn;
}

Normal SurfaceNormals::vertex_shape_centroid(const SurfaceMesh& mesh, Vertex v)
{
    Point nn(0, 0, 0);

    if (!mesh.is_isolated(v))
    {
        auto vpoint = mesh.get_vertex_property<Point>("v:point");
        const Point p0 = vpoint[v];

        Normal n;
        Point p1, p2, centroid;
        Scalar lambda, a, b, c, Cen, denom, cosine, angle;
        bool is_triangle;

        for (auto h : mesh.halfedges(v))
        {
            if (!mesh.is_boundary(h))
            {
                p1 = vpoint[mesh.to_vertex(h)];
                p1 -= p0;
                p2 = vpoint[mesh.from_vertex(mesh.prev_halfedge(h))];
                p2 -= p0;

                a = sqrt(dot(p1, p1));
                b = sqrt(dot(p2, p2));
                c = sqrt(dot(p1 - p2, p1 - p2));

                lambda = (a + b - c) * (a + c - b) * (b + c - a) / (a * b * c);

                centroid = (p1 + p2) / 3;
                Cen = sqrt(dot(centroid,centroid));

                is_triangle = (mesh.next_halfedge(mesh.next_halfedge(mesh.next_halfedge(h))) == h);

                n = is_triangle ? normalize(cross(p1, p2)): compute_face_normal(mesh, mesh.face(h));

                n = lambda * n / Cen;
                nn += n;
            }
        }

        nn = normalize(nn);
    }
    return nn;
}



Normal SurfaceNormals::vertex_angle_perimeter(const SurfaceMesh& mesh, Vertex v)
{
    Point nn(0, 0, 0);

    if (!mesh.is_isolated(v))
    {
        auto vpoint = mesh.get_vertex_property<Point>("v:point");
        const Point p0 = vpoint[v];

        Normal n;
        Point p1, p2, centroid;
        Scalar sina, a, b, c, Cen, perimeter,denom;
        bool is_triangle;

        for (auto h : mesh.halfedges(v))
        {
            if (!mesh.is_boundary(h))
            {
                p1 = vpoint[mesh.to_vertex(h)];
                p1 -= p0;
                p2 = vpoint[mesh.from_vertex(mesh.prev_halfedge(h))];
                p2 -= p0;

                a = sqrt(dot(p1, p1));
                b = sqrt(dot(p2, p2));
                c = sqrt(dot(p1 - p2, p1 - p2));

                denom = sqrt(dot(p1, p1) * dot(p2, p2));
                if (denom > std::numeric_limits<Scalar>::min())
                {
                    sina = dot(p1, p2) / denom;
                    if (sina < -1.0)
                        sina = -1.0;
                    else if (sina > 1.0)
                        sina = 1.0;
                }
                sina = sqrt(1 - sina * sina);
                

                centroid = (p1 + p2) / 3;
                Cen = sqrt(dot(centroid, centroid));
                Cen = sqrt(Cen);

                perimeter = sqrt(a + b + c);

                is_triangle = (mesh.next_halfedge(mesh.next_halfedge(mesh.next_halfedge(h))) == h);

                n = is_triangle ? normalize(cross(p1, p2)) : compute_face_normal(mesh, mesh.face(h));

                n = sina / (Cen * perimeter) * n;
                nn += n;
            }
        }

        nn = normalize(nn);
    }
    return nn;
}


void SurfaceNormals::shape_angle_centroid(SurfaceMesh& mesh)
{
    Normal el, er, ell(0, 0, 0), err(0, 0, 0), ne;
    float el_length, er_length, ell_length = 0, err_length = 0;
    int n = 0;
    std::vector<Vertex>boundary;
    auto vnormal = mesh.vertex_property<Normal>("v:normal");
    for (auto v : mesh.vertices())
    {
        Halfedge h, hl, hr;

        if (!mesh.is_boundary(v))
            vnormal[v] = shape_angle_centroid(mesh, v);
        else
        {
            boundary.push_back(v);
            Vertex next_vertex;
            for (Halfedge hh : mesh.halfedges(v))
            {
                if (mesh.is_boundary(hh))
                    h = hl = hr = hh;
            }
            while (mesh.from_vertex(mesh.next_halfedge(h)) != v)
            {
                boundary.push_back(mesh.from_vertex(mesh.next_halfedge(h)));
                h = mesh.next_halfedge(h);
            }


            if (n == 0)
                n = round(boundary.size() / 10);

            Vertex vl;
            for (int i = 1; i < n + 1; ++i)
            {
                vl = mesh.from_vertex(mesh.prev_halfedge(hl));
                el = mesh.position(vl) - mesh.position(v);
                el_length = sqrt(dot(el, el));
                ell_length = ell_length + el_length;
                ell = ell + el;
                hl = mesh.prev_halfedge(hl);
            }
            ell = ell / ell_length;


            Vertex vr;
            for (int i = 1; i < n + 1; ++i)
            {
                vr = mesh.from_vertex(mesh.next_halfedge(hr));
                er = mesh.position(vr) - mesh.position(v);
                er_length = sqrt(dot(er, er));
                err_length = err_length + er_length;
                err = err + er;
                hr = mesh.prev_halfedge(hr);
            }
            err = err / err_length;

            ne = cross(el, er);
            ne = normalize(ne);
            auto v_bound = mesh.get_vertex_property<bool>("v:bound");

            for (Vertex v : mesh.vertices())
            {
                //if(v_bound[v]==1)
                //    vnormal[v] = 0.995 * vertex_shape_centroid(mesh, v) + 0.005 * ne;
                //else
                vnormal[v] = 0.95 * shape_angle_centroid(mesh, v) + 0.05 * ne;
            }

        }
    }
}

Normal SurfaceNormals::shape_angle_centroid(const SurfaceMesh& mesh, Vertex v)
{
    Point nn(0, 0, 0);

    if (!mesh.is_isolated(v))
    {
        auto vpoint = mesh.get_vertex_property<Point>("v:point");
        const Point p0 = vpoint[v];

        Normal n;
        Point p1, p2, centroid;
        Scalar lambda, a, b, c, Cen, denom, cosine, angle;
        bool is_triangle;

        for (auto h : mesh.halfedges(v))
        {
            if (!mesh.is_boundary(h))
            {
                p1 = vpoint[mesh.to_vertex(h)];
                p1 -= p0;
                p2 = vpoint[mesh.from_vertex(mesh.prev_halfedge(h))];
                p2 -= p0;

                a = sqrt(dot(p1, p1));
                b = sqrt(dot(p2, p2));
                c = sqrt(dot(p1 - p2, p1 - p2));


                denom = sqrt(dot(p1, p1) * dot(p2, p2));
                if (denom > std::numeric_limits<Scalar>::min())
                {
                    cosine = dot(p1, p2) / denom;
                    if (cosine < -1.0)
                        cosine = -1.0;
                    else if (cosine > 1.0)
                        cosine = 1.0;
                    angle = acos(cosine);
                }

                angle = pow(angle, 1.0 / 3);


                lambda = (a + b - c) * (a + c - b) * (b + c - a) / (a * b * c);

                centroid = (p1 + p2) / 3;
                Cen = sqrt(dot(centroid, centroid));

                is_triangle = (mesh.next_halfedge(mesh.next_halfedge(mesh.next_halfedge(h))) == h);

                n = is_triangle ? normalize(cross(p1, p2)) : compute_face_normal(mesh, mesh.face(h));

                n = angle * lambda * n / Cen;
                nn += n;
            }
        }

        nn = normalize(nn);
    }
    return nn;
}

void SurfaceNormals::vertex_angle_centroid(SurfaceMesh& mesh)
{
    auto vnormal = mesh.vertex_property<Normal>("v:normal");
    for (auto v : mesh.vertices())
        vnormal[v] = vertex_angle_centroid(mesh, v);
}

Normal SurfaceNormals::vertex_angle_centroid(const SurfaceMesh& mesh, Vertex v)
{
    Point nn(0, 0, 0);

    if (!mesh.is_isolated(v))
    {
        auto vpoint = mesh.get_vertex_property<Point>("v:point");
        const Point p0 = vpoint[v];

        Normal n;
        Point p1, p2, centroid;
        Scalar  a, b, c, Cen, denom, cosine, angle = 0;
        bool is_triangle;

        for (auto h : mesh.halfedges(v))
        {
            if (!mesh.is_boundary(h))
            {
                p1 = vpoint[mesh.to_vertex(h)];
                p1 -= p0;
                p2 = vpoint[mesh.from_vertex(mesh.prev_halfedge(h))];
                p2 -= p0;

                a = sqrt(dot(p1, p1));
                b = sqrt(dot(p2, p2));
                c = sqrt(dot(p1 - p2, p1 - p2));


                denom = sqrt(dot(p1, p1) * dot(p2, p2));
                if (denom > std::numeric_limits<Scalar>::min())
                {
                    cosine = dot(p1, p2) / denom;
                    if (cosine < -1.0)
                        cosine = -1.0;
                    else if (cosine > 1.0)
                        cosine = 1.0;
                    angle = acos(cosine);
                }


                centroid = (p1 + p2) / 3;
                Cen = sqrt(dot(centroid, centroid));
                

                is_triangle = (mesh.next_halfedge(mesh.next_halfedge(mesh.next_halfedge(h))) == h);

                n = is_triangle ? normalize(cross(p1, p2)) : compute_face_normal(mesh, mesh.face(h));

                n = angle * n / Cen;
                nn += n;
            }
        }

        nn = normalize(nn);
    }
    return nn;
}


void SurfaceNormals::vertex_angle_perimeter(SurfaceMesh& mesh)
{
    auto vnormal = mesh.vertex_property<Normal>("v:normal");
    for (auto v : mesh.vertices())
        vnormal[v] = vertex_angle_perimeter(mesh, v);
}

void SurfaceNormals::compute_vertex_normals(SurfaceMesh& mesh)
{
    auto vnormal = mesh.vertex_property<Normal>("v:normal");
    for (auto v : mesh.vertices())
        vnormal[v] = compute_vertex_normal(mesh, v);
}

void SurfaceNormals::compute_face_normals(SurfaceMesh& mesh)
{
    auto fnormal = mesh.face_property<Normal>("f:normal");
    for (auto f : mesh.faces())
        fnormal[f] = compute_face_normal(mesh, f);
}

void SurfaceNormals::vertex_shape_centroid(SurfaceMesh& mesh)
{
    auto vnormal = mesh.vertex_property<Normal>("v:normal");
    for (auto v : mesh.vertices())
        vnormal[v] = vertex_shape_centroid(mesh, v);
}



} // namespace pmp
